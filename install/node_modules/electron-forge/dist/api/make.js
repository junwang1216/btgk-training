'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _bluebird = require('bluebird');

require('colors');

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _targets = require('electron-packager/targets');

var _oraHandler = require('../util/ora-handler');

var _oraHandler2 = _interopRequireDefault(_oraHandler);

var _forgeConfig = require('../util/forge-config');

var _forgeConfig2 = _interopRequireDefault(_forgeConfig);

var _hook = require('../util/hook');

var _hook2 = _interopRequireDefault(_hook);

var _messages = require('../util/messages');

var _parseArchs = require('../util/parse-archs');

var _parseArchs2 = _interopRequireDefault(_parseArchs);

var _readPackageJson = require('../util/read-package-json');

var _readPackageJson2 = _interopRequireDefault(_readPackageJson);

var _requireSearch = require('../util/require-search');

var _resolveDir = require('../util/resolve-dir');

var _resolveDir2 = _interopRequireDefault(_resolveDir);

var _outDir = require('../util/out-dir');

var _outDir2 = _interopRequireDefault(_outDir);

var _package = require('./package');

var _package2 = _interopRequireDefault(_package);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} MakeOptions
 * @property {string} [dir=process.cwd()] The path to the app from which distributables are generated
 * @property {boolean} [interactive=false] Whether to use sensible defaults or prompt the user visually
 * @property {boolean} [skipPackage=false] Whether to skip the pre-make packaging step
 * @property {Array<string>} [overrideTargets] An array of make targets to override your forge config
 * @property {string} [arch=host architecture] The target architecture
 * @property {string} [platform=process.platform] The target platform.
 * @property {string} [outDir=`${dir}/out`] The path to the directory containing generated distributables
 */

/**
 * @typedef {Object} MakeResult
 * @property {Array<string>} artifacts An array of paths to artifacts generated for this make run
 * @property {Object} packageJSON The state of the package.json file when the make happened
 * @property {string} platform The platform this make run was for
 * @property {string} arch The arch this make run was for
 */

/**
 * Make distributables for an Electron application.
 *
 * @param {MakeOptions} providedOptions - Options for the make method
 * @return {Promise<Array<MakeResult>>} Will resolve when the make process is complete
 */
exports.default = (() => {
  var _ref = (0, _bluebird.coroutine)(function* (providedOptions = {}) {
    // eslint-disable-next-line prefer-const, no-unused-vars
    var _Object$assign = (0, _assign2.default)({
      dir: process.cwd(),
      interactive: false,
      skipPackage: false,
      arch: (0, _targets.hostArch)(),
      platform: process.platform
    }, providedOptions);

    let dir = _Object$assign.dir,
        interactive = _Object$assign.interactive,
        skipPackage = _Object$assign.skipPackage,
        overrideTargets = _Object$assign.overrideTargets,
        arch = _Object$assign.arch,
        platform = _Object$assign.platform;


    _oraHandler2.default.interactive = interactive;

    let forgeConfig;
    yield (0, _oraHandler2.default)('Resolving Forge Config', (0, _bluebird.coroutine)(function* () {
      dir = yield (0, _resolveDir2.default)(dir);
      if (!dir) {
        throw 'Failed to locate makeable Electron application';
      }

      forgeConfig = yield (0, _forgeConfig2.default)(dir);
    }));

    const outDir = providedOptions.outDir || (0, _outDir2.default)(dir, forgeConfig);

    const actualTargetPlatform = platform;
    platform = platform === 'mas' ? 'darwin' : platform;
    if (!['darwin', 'win32', 'linux', 'mas'].includes(actualTargetPlatform)) {
      throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
    }

    const makers = {};
    const targets = overrideTargets || forgeConfig.make_targets[platform];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(targets), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const target = _step.value;

        const maker = (0, _requireSearch.requireSearchRaw)(__dirname, [`../makers/${platform}/${target}.js`, `../makers/generic/${target}.js`, `electron-forge-maker-${target}`, target, _path2.default.resolve(dir, target), _path2.default.resolve(dir, 'node_modules', target)]);

        if (!maker) {
          throw new Error(['Could not find a build target with the name: ', `${target} for the platform: ${actualTargetPlatform}`].join(''));
        }

        if (!maker.isSupportedOnCurrentPlatform) {
          throw new Error([`Maker for target ${target} is incompatible with this version of `, 'electron-forge, please upgrade or contact the maintainer ', '(needs to implement \'isSupportedOnCurrentPlatform)\')'].join(''));
        }

        if (!(yield maker.isSupportedOnCurrentPlatform())) {
          throw new Error([`Cannot build for ${platform} target ${target}: the maker declared `, `that it cannot run on ${process.platform}`].join(''));
        }

        makers[target] = maker.default || maker;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!skipPackage) {
      (0, _messages.info)(interactive, 'We need to package your application before we can make it'.green);
      yield (0, _package2.default)({
        dir,
        interactive,
        arch,
        outDir,
        platform: actualTargetPlatform
      });
    } else {
      (0, _messages.warn)(interactive, 'WARNING: Skipping the packaging step, this could result in an out of date build'.red);
    }

    (0, _messages.info)(interactive, 'Making for the following targets:', `${targets.join(', ')}`.cyan);

    const packageJSON = yield (0, _readPackageJson2.default)(dir);
    const appName = forgeConfig.electronPackagerConfig.name || packageJSON.productName || packageJSON.name;
    let outputs = [];

    yield (0, _hook2.default)(forgeConfig, 'preMake');

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)((0, _parseArchs2.default)(platform, arch, packageJSON.devDependencies['electron-prebuilt-compile'])), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        const targetArch = _step2.value;

        const packageDir = _path2.default.resolve(outDir, `${appName}-${actualTargetPlatform}-${targetArch}`);
        if (!(yield _fsExtra2.default.pathExists(packageDir))) {
          throw new Error(`Couldn't find packaged app at: ${packageDir}`);
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _getIterator3.default)(targets), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            const target = _step3.value;

            const maker = makers[target];

            // eslint-disable-next-line no-loop-func
            yield (0, _oraHandler2.default)(`Making for target: ${target.cyan} - On platform: ${actualTargetPlatform.cyan} - For arch: ${targetArch.cyan}`, (0, _bluebird.coroutine)(function* () {
              try {
                const artifacts = yield maker({
                  dir: packageDir,
                  appName,
                  targetPlatform: actualTargetPlatform,
                  targetArch,
                  forgeConfig,
                  packageJSON
                });

                outputs.push({
                  artifacts,
                  packageJSON,
                  platform: actualTargetPlatform,
                  arch: targetArch
                });
              } catch (err) {
                if (err) {
                  throw {
                    message: `An error occured while making for target: ${target}`,
                    stack: `${err.message}\n${err.stack}`
                  };
                } else {
                  throw new Error(`An unknown error occured while making for target: ${target}`);
                }
              }
            }));
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    const result = yield (0, _hook2.default)(forgeConfig, 'postMake', outputs);
    // If the postMake hooks modifies the locations / names of the outputs it must return
    // the new locations so that the publish step knows where to look
    if (Array.isArray(result)) {
      outputs = result;
    }

    return outputs;
  });

  return function () {
    return _ref.apply(this, arguments);
  };
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwaS9tYWtlLmpzIl0sIm5hbWVzIjpbInByb3ZpZGVkT3B0aW9ucyIsImRpciIsInByb2Nlc3MiLCJjd2QiLCJpbnRlcmFjdGl2ZSIsInNraXBQYWNrYWdlIiwiYXJjaCIsInBsYXRmb3JtIiwib3ZlcnJpZGVUYXJnZXRzIiwiZm9yZ2VDb25maWciLCJvdXREaXIiLCJhY3R1YWxUYXJnZXRQbGF0Zm9ybSIsImluY2x1ZGVzIiwiRXJyb3IiLCJtYWtlcnMiLCJ0YXJnZXRzIiwibWFrZV90YXJnZXRzIiwidGFyZ2V0IiwibWFrZXIiLCJfX2Rpcm5hbWUiLCJyZXNvbHZlIiwiam9pbiIsImlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0iLCJkZWZhdWx0IiwiZ3JlZW4iLCJyZWQiLCJjeWFuIiwicGFja2FnZUpTT04iLCJhcHBOYW1lIiwiZWxlY3Ryb25QYWNrYWdlckNvbmZpZyIsIm5hbWUiLCJwcm9kdWN0TmFtZSIsIm91dHB1dHMiLCJkZXZEZXBlbmRlbmNpZXMiLCJ0YXJnZXRBcmNoIiwicGFja2FnZURpciIsInBhdGhFeGlzdHMiLCJhcnRpZmFjdHMiLCJ0YXJnZXRQbGF0Zm9ybSIsInB1c2giLCJlcnIiLCJtZXNzYWdlIiwic3RhY2siLCJyZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7O0FBUUE7Ozs7Ozs7c0NBTWUsV0FBT0Esa0JBQWtCLEVBQXpCLEVBQWdDO0FBQzdDO0FBRDZDLHlCQUU0QixzQkFBYztBQUNyRkMsV0FBS0MsUUFBUUMsR0FBUixFQURnRjtBQUVyRkMsbUJBQWEsS0FGd0U7QUFHckZDLG1CQUFhLEtBSHdFO0FBSXJGQyxZQUFNLHdCQUorRTtB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QUFDRCxHIiwiZmlsZSI6ImFwaS9tYWtlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb2xvcnMnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgaG9zdEFyY2ggfSBmcm9tICdlbGVjdHJvbi1wYWNrYWdlci90YXJnZXRzJztcblxuaW1wb3J0IGFzeW5jT3JhIGZyb20gJy4uL3V0aWwvb3JhLWhhbmRsZXInO1xuaW1wb3J0IGdldEZvcmdlQ29uZmlnIGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcbmltcG9ydCBydW5Ib29rIGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyBpbmZvLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCByZWFkUGFja2FnZUpTT04gZnJvbSAnLi4vdXRpbC9yZWFkLXBhY2thZ2UtanNvbic7XG5pbXBvcnQgeyByZXF1aXJlU2VhcmNoUmF3IH0gZnJvbSAnLi4vdXRpbC9yZXF1aXJlLXNlYXJjaCc7XG5pbXBvcnQgcmVzb2x2ZURpciBmcm9tICcuLi91dGlsL3Jlc29sdmUtZGlyJztcbmltcG9ydCBnZXRDdXJyZW50T3V0RGlyIGZyb20gJy4uL3V0aWwvb3V0LWRpcic7XG5cbmltcG9ydCBwYWNrYWdlciBmcm9tICcuL3BhY2thZ2UnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ha2VPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Rpcj1wcm9jZXNzLmN3ZCgpXSBUaGUgcGF0aCB0byB0aGUgYXBwIGZyb20gd2hpY2ggZGlzdHJpYnV0YWJsZXMgYXJlIGdlbmVyYXRlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJhY3RpdmU9ZmFsc2VdIFdoZXRoZXIgdG8gdXNlIHNlbnNpYmxlIGRlZmF1bHRzIG9yIHByb21wdCB0aGUgdXNlciB2aXN1YWxseVxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2tpcFBhY2thZ2U9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCB0aGUgcHJlLW1ha2UgcGFja2FnaW5nIHN0ZXBcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW292ZXJyaWRlVGFyZ2V0c10gQW4gYXJyYXkgb2YgbWFrZSB0YXJnZXRzIHRvIG92ZXJyaWRlIHlvdXIgZm9yZ2UgY29uZmlnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2FyY2g9aG9zdCBhcmNoaXRlY3R1cmVdIFRoZSB0YXJnZXQgYXJjaGl0ZWN0dXJlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYXRmb3JtPXByb2Nlc3MucGxhdGZvcm1dIFRoZSB0YXJnZXQgcGxhdGZvcm0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW291dERpcj1gJHtkaXJ9L291dGBdIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyBnZW5lcmF0ZWQgZGlzdHJpYnV0YWJsZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ha2VSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gYXJ0aWZhY3RzIEFuIGFycmF5IG9mIHBhdGhzIHRvIGFydGlmYWN0cyBnZW5lcmF0ZWQgZm9yIHRoaXMgbWFrZSBydW5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwYWNrYWdlSlNPTiBUaGUgc3RhdGUgb2YgdGhlIHBhY2thZ2UuanNvbiBmaWxlIHdoZW4gdGhlIG1ha2UgaGFwcGVuZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwbGF0Zm9ybSBUaGUgcGxhdGZvcm0gdGhpcyBtYWtlIHJ1biB3YXMgZm9yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXJjaCBUaGUgYXJjaCB0aGlzIG1ha2UgcnVuIHdhcyBmb3JcbiAqL1xuXG4vKipcbiAqIE1ha2UgZGlzdHJpYnV0YWJsZXMgZm9yIGFuIEVsZWN0cm9uIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWFrZU9wdGlvbnN9IHByb3ZpZGVkT3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBtYWtlIG1ldGhvZFxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNYWtlUmVzdWx0Pj59IFdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBtYWtlIHByb2Nlc3MgaXMgY29tcGxldGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHByb3ZpZGVkT3B0aW9ucyA9IHt9KSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3QsIG5vLXVudXNlZC12YXJzXG4gIGxldCB7IGRpciwgaW50ZXJhY3RpdmUsIHNraXBQYWNrYWdlLCBvdmVycmlkZVRhcmdldHMsIGFyY2gsIHBsYXRmb3JtIH0gPSBPYmplY3QuYXNzaWduKHtcbiAgICBkaXI6IHByb2Nlc3MuY3dkKCksXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIHNraXBQYWNrYWdlOiBmYWxzZSxcbiAgICBhcmNoOiBob3N0QXJjaCgpLFxuICAgIHBsYXRmb3JtOiBwcm9jZXNzLnBsYXRmb3JtLFxuICB9LCBwcm92aWRlZE9wdGlvbnMpO1xuXG4gIGFzeW5jT3JhLmludGVyYWN0aXZlID0gaW50ZXJhY3RpdmU7XG5cbiAgbGV0IGZvcmdlQ29uZmlnO1xuICBhd2FpdCBhc3luY09yYSgnUmVzb2x2aW5nIEZvcmdlIENvbmZpZycsIGFzeW5jICgpID0+IHtcbiAgICBkaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gICAgaWYgKCFkaXIpIHtcbiAgICAgIHRocm93ICdGYWlsZWQgdG8gbG9jYXRlIG1ha2VhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJztcbiAgICB9XG5cbiAgICBmb3JnZUNvbmZpZyA9IGF3YWl0IGdldEZvcmdlQ29uZmlnKGRpcik7XG4gIH0pO1xuXG4gIGNvbnN0IG91dERpciA9IHByb3ZpZGVkT3B0aW9ucy5vdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICBjb25zdCBhY3R1YWxUYXJnZXRQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICBwbGF0Zm9ybSA9IHBsYXRmb3JtID09PSAnbWFzJyA/ICdkYXJ3aW4nIDogcGxhdGZvcm07XG4gIGlmICghWydkYXJ3aW4nLCAnd2luMzInLCAnbGludXgnLCAnbWFzJ10uaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX0nIGlzIGFuIGludmFsaWQgcGxhdGZvcm0uIENob2ljZXMgYXJlICdkYXJ3aW4nLCAnbWFzJywgJ3dpbjMyJyBvciAnbGludXgnYCk7XG4gIH1cblxuICBjb25zdCBtYWtlcnMgPSB7fTtcbiAgY29uc3QgdGFyZ2V0cyA9IG92ZXJyaWRlVGFyZ2V0cyB8fCBmb3JnZUNvbmZpZy5tYWtlX3RhcmdldHNbcGxhdGZvcm1dO1xuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCBtYWtlciA9IHJlcXVpcmVTZWFyY2hSYXcoX19kaXJuYW1lLCBbXG4gICAgICBgLi4vbWFrZXJzLyR7cGxhdGZvcm19LyR7dGFyZ2V0fS5qc2AsXG4gICAgICBgLi4vbWFrZXJzL2dlbmVyaWMvJHt0YXJnZXR9LmpzYCxcbiAgICAgIGBlbGVjdHJvbi1mb3JnZS1tYWtlci0ke3RhcmdldH1gLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcGF0aC5yZXNvbHZlKGRpciwgdGFyZ2V0KSxcbiAgICAgIHBhdGgucmVzb2x2ZShkaXIsICdub2RlX21vZHVsZXMnLCB0YXJnZXQpLFxuICAgIF0pO1xuXG4gICAgaWYgKCFtYWtlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIGEgYnVpbGQgdGFyZ2V0IHdpdGggdGhlIG5hbWU6ICcsXG4gICAgICAgIGAke3RhcmdldH0gZm9yIHRoZSBwbGF0Zm9ybTogJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX1gLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICBgTWFrZXIgZm9yIHRhcmdldCAke3RhcmdldH0gaXMgaW5jb21wYXRpYmxlIHdpdGggdGhpcyB2ZXJzaW9uIG9mIGAsXG4gICAgICAgICdlbGVjdHJvbi1mb3JnZSwgcGxlYXNlIHVwZ3JhZGUgb3IgY29udGFjdCB0aGUgbWFpbnRhaW5lciAnLFxuICAgICAgICAnKG5lZWRzIHRvIGltcGxlbWVudCBcXCdpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKVxcJyknLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFhd2FpdCBtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGBDYW5ub3QgYnVpbGQgZm9yICR7cGxhdGZvcm19IHRhcmdldCAke3RhcmdldH06IHRoZSBtYWtlciBkZWNsYXJlZCBgLFxuICAgICAgICBgdGhhdCBpdCBjYW5ub3QgcnVuIG9uICR7cHJvY2Vzcy5wbGF0Zm9ybX1gLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgbWFrZXJzW3RhcmdldF0gPSBtYWtlci5kZWZhdWx0IHx8IG1ha2VyO1xuICB9XG5cbiAgaWYgKCFza2lwUGFja2FnZSkge1xuICAgIGluZm8oaW50ZXJhY3RpdmUsICdXZSBuZWVkIHRvIHBhY2thZ2UgeW91ciBhcHBsaWNhdGlvbiBiZWZvcmUgd2UgY2FuIG1ha2UgaXQnLmdyZWVuKTtcbiAgICBhd2FpdCBwYWNrYWdlcih7XG4gICAgICBkaXIsXG4gICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgIGFyY2gsXG4gICAgICBvdXREaXIsXG4gICAgICBwbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybihpbnRlcmFjdGl2ZSwgJ1dBUk5JTkc6IFNraXBwaW5nIHRoZSBwYWNrYWdpbmcgc3RlcCwgdGhpcyBjb3VsZCByZXN1bHQgaW4gYW4gb3V0IG9mIGRhdGUgYnVpbGQnLnJlZCk7XG4gIH1cblxuICBpbmZvKGludGVyYWN0aXZlLCAnTWFraW5nIGZvciB0aGUgZm9sbG93aW5nIHRhcmdldHM6JywgYCR7dGFyZ2V0cy5qb2luKCcsICcpfWAuY3lhbik7XG5cbiAgY29uc3QgcGFja2FnZUpTT04gPSBhd2FpdCByZWFkUGFja2FnZUpTT04oZGlyKTtcbiAgY29uc3QgYXBwTmFtZSA9IGZvcmdlQ29uZmlnLmVsZWN0cm9uUGFja2FnZXJDb25maWcubmFtZSB8fCBwYWNrYWdlSlNPTi5wcm9kdWN0TmFtZSB8fCBwYWNrYWdlSlNPTi5uYW1lO1xuICBsZXQgb3V0cHV0cyA9IFtdO1xuXG4gIGF3YWl0IHJ1bkhvb2soZm9yZ2VDb25maWcsICdwcmVNYWtlJyk7XG5cbiAgZm9yIChjb25zdCB0YXJnZXRBcmNoIG9mIHBhcnNlQXJjaHMocGxhdGZvcm0sIGFyY2gsIHBhY2thZ2VKU09OLmRldkRlcGVuZGVuY2llc1snZWxlY3Ryb24tcHJlYnVpbHQtY29tcGlsZSddKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUob3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICBjb25zdCBtYWtlciA9IG1ha2Vyc1t0YXJnZXRdO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICBhd2FpdCBhc3luY09yYShgTWFraW5nIGZvciB0YXJnZXQ6ICR7dGFyZ2V0LmN5YW59IC0gT24gcGxhdGZvcm06ICR7YWN0dWFsVGFyZ2V0UGxhdGZvcm0uY3lhbn0gLSBGb3IgYXJjaDogJHt0YXJnZXRBcmNoLmN5YW59YCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGFydGlmYWN0cyA9IGF3YWl0IG1ha2VyKHtcbiAgICAgICAgICAgIGRpcjogcGFja2FnZURpcixcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICB0YXJnZXRQbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgICAgICAgICB0YXJnZXRBcmNoLFxuICAgICAgICAgICAgZm9yZ2VDb25maWcsXG4gICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICBhcnRpZmFjdHMsXG4gICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgIHBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICAgICAgICAgIGFyY2g6IHRhcmdldEFyY2gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7dGFyZ2V0fWAsXG4gICAgICAgICAgICAgIHN0YWNrOiBgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiB1bmtub3duIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7dGFyZ2V0fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3Bvc3RNYWtlJywgb3V0cHV0cyk7XG4gIC8vIElmIHRoZSBwb3N0TWFrZSBob29rcyBtb2RpZmllcyB0aGUgbG9jYXRpb25zIC8gbmFtZXMgb2YgdGhlIG91dHB1dHMgaXQgbXVzdCByZXR1cm5cbiAgLy8gdGhlIG5ldyBsb2NhdGlvbnMgc28gdGhhdCB0aGUgcHVibGlzaCBzdGVwIGtub3dzIHdoZXJlIHRvIGxvb2tcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgIG91dHB1dHMgPSByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0cztcbn07XG4iXX0=