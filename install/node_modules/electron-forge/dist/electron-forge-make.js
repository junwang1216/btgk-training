'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMakeOptions = undefined;

var _bluebird = require('bluebird');

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _commander = require('commander');

var _commander2 = _interopRequireDefault(_commander);

require('./util/terminate');

var _api = require('./api');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/prefer-default-export
const getMakeOptions = exports.getMakeOptions = () => {
  let dir = process.cwd();
  _commander2.default.version(require('../package.json').version).arguments('[cwd]').option('--skip-package', 'Assume the app is already packaged').option('-a, --arch [arch]', 'Target architecture').option('-p, --platform [platform]', 'Target build platform').option('--targets [targets]', 'Override your make targets for this run').allowUnknownOption(true).action(cwd => {
    if (!cwd) return;
    if (_path2.default.isAbsolute(cwd) && _fsExtra2.default.existsSync(cwd)) {
      dir = cwd;
    } else if (_fsExtra2.default.existsSync(_path2.default.resolve(dir, cwd))) {
      dir = _path2.default.resolve(dir, cwd);
    }
  }).parse(process.argv);

  const makeOpts = {
    dir,
    interactive: true,
    skipPackage: _commander2.default.skipPackage
  };
  if (_commander2.default.targets) makeOpts.overrideTargets = _commander2.default.targets.split(',');
  if (_commander2.default.arch) makeOpts.arch = _commander2.default.arch;
  if (_commander2.default.platform) makeOpts.platform = _commander2.default.platform;

  return makeOpts;
};

if (process.mainModule === module || global.__LINKED_FORGE__) {
  (0, _bluebird.coroutine)(function* () {
    const makeOpts = getMakeOptions();

    yield (0, _api.make)(makeOpts);
  })();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZWN0cm9uLWZvcmdlLW1ha2UuanMiXSwibmFtZXMiOlsiZ2V0TWFrZU9wdGlvbnMiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwidmVyc2lvbiIsInJlcXVpcmUiLCJhcmd1bWVudHMiLCJvcHRpb24iLCJhbGxvd1Vua25vd25PcHRpb24iLCJhY3Rpb24iLCJpc0Fic29sdXRlIiwiZXhpc3RzU3luYyIsInJlc29sdmUiLCJwYXJzZSIsImFyZ3YiLCJtYWtlT3B0cyIsImludGVyYWN0aXZlIiwic2tpcFBhY2thZ2UiLCJ0YXJnZXRzIiwib3ZlcnJpZGVUYXJnZXRzIiwic3BsaXQiLCJhcmNoIiwicGxhdGZvcm0iLCJtYWluTW9kdWxlIiwibW9kdWxlIiwiZ2xvYmFsIiwiX19MSU5LRURfRk9SR0VfXyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7O0FBQ0E7Ozs7QUFFQTtBQUNPLE1BQU1BLDBDQUFpQixNQUFNO0FBQ2xDLE1BQUlDLE1BQU1DLFFBQVFDLEdBQVIsRUFBVjtBQUNBLHNCQUNHQyxPQURILENBQ1dDLFFBQVEsaUJBQVIsRUFBMkJELE9BRHRDLEVBRUdFLFNBRkgsQ0FFYSxPQUZiLEVBR0dDLE1BSEgsQ0FHVSxnQkFIVixFQUc0QixvQ0FINUIsRUFJR0EsTUFKSCxDQUlVLG1CQUpWLEVBSStCLHFCQUovQixFQUtHQSxNQUxILENBS1UsMkJBTFYsRUFLdUMsdUJBTHZDLEVBTUdBLE1BTkgsQ0FNVSxxQkFOVixFQU1pQyx5Q0FOakMsRUFPR0Msa0JBUEgsQ0FPc0IsSUFQdEIsRUFRR0MsTUFSSCxDQVFXTixHQUFELElBQVM7QUFDZixRQUFJLENBQUNBLEdBQUwsRUFBVTtBQUNWLFFBQUksZUFBS08sVUFBTCxDQUFnQlAsR0FBaEIsS0FBd0Isa0JBQUdRLFVBQUgsQ0FBY1IsR0FBZCxDQUE1QixFQUFnRDtBQUM5Q0YsWUFBTUUsR0FBTjtBQUNELEtBRkQsTUFFTyxJQUFJLGtCQUFHUSxVQUFILENBQWMsZUFBS0MsT0FBTCxDQUFhWCxHQUFiLEVBQWtCRSxHQUFsQixDQUFkLENBQUosRUFBMkM7QUFDaERGLFlBQU0sZUFBS1csT0FBTCxDQUFhWCxHQUFiLEVBQWtCRSxHQUFsQixDQUFOO0FBQ0Q7QUFDRixHQWZILEVBZ0JHVSxLQWhCSCxDQWdCU1gsUUFBUVksSUFoQmpCOztBQWtCQSxRQUFNQyxXQUFXO0FBQ2ZkLE9BRGU7QUFFZmUsaUJBQWEsSUFGRTtBQUdmQyxpQkFBYSxvQkFBUUE7QUFITixHQUFqQjtBQUtBLE1BQUksb0JBQVFDLE9BQVosRUFBcUJILFNBQVNJLGVBQVQsR0FBMkIsb0JBQVFELE9BQVIsQ0FBZ0JFLEtBQWhCLENBQXNCLEdBQXRCLENBQTNCO0FBQ3JCLE1BQUksb0JBQVFDLElBQVosRUFBa0JOLFNBQVNNLElBQVQsR0FBZ0Isb0JBQVFBLElBQXhCO0FBQ2xCLE1BQUksb0JBQVFDLFFBQVosRUFBc0JQLFNBQVNPLFFBQVQsR0FBb0Isb0JBQVFBLFFBQTVCOztBQUV0QixTQUFPUCxRQUFQO0FBQ0QsQ0E5Qk07O0FBZ0NQLElBQUliLFFBQVFxQixVQUFSLEtBQXVCQyxNQUF2QixJQUFpQ0MsT0FBT0MsZ0JBQTVDLEVBQThEO0FBQzVELDJCQUFDLGFBQVk7QUFDWCxVQUFNWCxXQUFXZixnQkFBakI7O0FBRUEsVUFBTSxlQUFLZSxRQUFMLENBQU47QUFDRCxHQUpEO0FBS0QiLCJmaWxlIjoiZWxlY3Ryb24tZm9yZ2UtbWFrZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBwcm9ncmFtIGZyb20gJ2NvbW1hbmRlcic7XG5cbmltcG9ydCAnLi91dGlsL3Rlcm1pbmF0ZSc7XG5pbXBvcnQgeyBtYWtlIH0gZnJvbSAnLi9hcGknO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydFxuZXhwb3J0IGNvbnN0IGdldE1ha2VPcHRpb25zID0gKCkgPT4ge1xuICBsZXQgZGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgcHJvZ3JhbVxuICAgIC52ZXJzaW9uKHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24pXG4gICAgLmFyZ3VtZW50cygnW2N3ZF0nKVxuICAgIC5vcHRpb24oJy0tc2tpcC1wYWNrYWdlJywgJ0Fzc3VtZSB0aGUgYXBwIGlzIGFscmVhZHkgcGFja2FnZWQnKVxuICAgIC5vcHRpb24oJy1hLCAtLWFyY2ggW2FyY2hdJywgJ1RhcmdldCBhcmNoaXRlY3R1cmUnKVxuICAgIC5vcHRpb24oJy1wLCAtLXBsYXRmb3JtIFtwbGF0Zm9ybV0nLCAnVGFyZ2V0IGJ1aWxkIHBsYXRmb3JtJylcbiAgICAub3B0aW9uKCctLXRhcmdldHMgW3RhcmdldHNdJywgJ092ZXJyaWRlIHlvdXIgbWFrZSB0YXJnZXRzIGZvciB0aGlzIHJ1bicpXG4gICAgLmFsbG93VW5rbm93bk9wdGlvbih0cnVlKVxuICAgIC5hY3Rpb24oKGN3ZCkgPT4ge1xuICAgICAgaWYgKCFjd2QpIHJldHVybjtcbiAgICAgIGlmIChwYXRoLmlzQWJzb2x1dGUoY3dkKSAmJiBmcy5leGlzdHNTeW5jKGN3ZCkpIHtcbiAgICAgICAgZGlyID0gY3dkO1xuICAgICAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKHBhdGgucmVzb2x2ZShkaXIsIGN3ZCkpKSB7XG4gICAgICAgIGRpciA9IHBhdGgucmVzb2x2ZShkaXIsIGN3ZCk7XG4gICAgICB9XG4gICAgfSlcbiAgICAucGFyc2UocHJvY2Vzcy5hcmd2KTtcblxuICBjb25zdCBtYWtlT3B0cyA9IHtcbiAgICBkaXIsXG4gICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgc2tpcFBhY2thZ2U6IHByb2dyYW0uc2tpcFBhY2thZ2UsXG4gIH07XG4gIGlmIChwcm9ncmFtLnRhcmdldHMpIG1ha2VPcHRzLm92ZXJyaWRlVGFyZ2V0cyA9IHByb2dyYW0udGFyZ2V0cy5zcGxpdCgnLCcpO1xuICBpZiAocHJvZ3JhbS5hcmNoKSBtYWtlT3B0cy5hcmNoID0gcHJvZ3JhbS5hcmNoO1xuICBpZiAocHJvZ3JhbS5wbGF0Zm9ybSkgbWFrZU9wdHMucGxhdGZvcm0gPSBwcm9ncmFtLnBsYXRmb3JtO1xuXG4gIHJldHVybiBtYWtlT3B0cztcbn07XG5cbmlmIChwcm9jZXNzLm1haW5Nb2R1bGUgPT09IG1vZHVsZSB8fCBnbG9iYWwuX19MSU5LRURfRk9SR0VfXykge1xuICAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1ha2VPcHRzID0gZ2V0TWFrZU9wdGlvbnMoKTtcblxuICAgIGF3YWl0IG1ha2UobWFrZU9wdHMpO1xuICB9KSgpO1xufVxuIl19